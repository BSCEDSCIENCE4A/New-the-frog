{"ast":null,"code":"/**\n * @author jbouny / https://github.com/jbouny\n *\n * Work based on :\n * @author Slayvin / http://slayvin.net : Flat mirror for three.js\n * @author Stemkoski / http://www.adelphi.edu/~stemkoski : An implementation of water shader based on the flat mirror\n * @author Jonas Wagner / http://29a.ch/ && http://29a.ch/slides/2012/webglwater/ : Water shader explanations in WebGL\n */\nTHREE.Water = function (geometry, options) {\n  THREE.Mesh.call(this, geometry);\n  var scope = this;\n  options = options || {};\n  var textureWidth = options.textureWidth !== undefined ? options.textureWidth : 512;\n  var textureHeight = options.textureHeight !== undefined ? options.textureHeight : 512;\n  var clipBias = options.clipBias !== undefined ? options.clipBias : 0.0;\n  var alpha = options.alpha !== undefined ? options.alpha : 1.0;\n  var time = options.time !== undefined ? options.time : 0.0;\n  var normalSampler = options.waterNormals !== undefined ? options.waterNormals : null;\n  var sunDirection = options.sunDirection !== undefined ? options.sunDirection : new THREE.Vector3(0.70707, 0.70707, 0.0);\n  var sunColor = new THREE.Color(options.sunColor !== undefined ? options.sunColor : 0xffffff);\n  var waterColor = new THREE.Color(options.waterColor !== undefined ? options.waterColor : 0x7F7F7F);\n  var eye = options.eye !== undefined ? options.eye : new THREE.Vector3(0, 0, 0);\n  var distortionScale = options.distortionScale !== undefined ? options.distortionScale : 20.0;\n  var side = options.side !== undefined ? options.side : THREE.FrontSide;\n  var fog = options.fog !== undefined ? options.fog : false; //\n\n  var mirrorPlane = new THREE.Plane();\n  var normal = new THREE.Vector3();\n  var mirrorWorldPosition = new THREE.Vector3();\n  var cameraWorldPosition = new THREE.Vector3();\n  var rotationMatrix = new THREE.Matrix4();\n  var lookAtPosition = new THREE.Vector3(0, 0, -1);\n  var clipPlane = new THREE.Vector4();\n  var view = new THREE.Vector3();\n  var target = new THREE.Vector3();\n  var q = new THREE.Vector4();\n  var textureMatrix = new THREE.Matrix4();\n  var mirrorCamera = new THREE.PerspectiveCamera();\n  var parameters = {\n    minFilter: THREE.LinearFilter,\n    magFilter: THREE.LinearFilter,\n    format: THREE.RGBFormat,\n    stencilBuffer: false\n  };\n  var renderTarget = new THREE.WebGLRenderTarget(textureWidth, textureHeight, parameters);\n\n  if (!THREE.Math.isPowerOfTwo(textureWidth) || !THREE.Math.isPowerOfTwo(textureHeight)) {\n    renderTarget.texture.generateMipmaps = false;\n  }\n\n  var mirrorShader = {\n    uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib['fog'], THREE.UniformsLib['lights'], {\n      \"normalSampler\": {\n        value: null\n      },\n      \"mirrorSampler\": {\n        value: null\n      },\n      \"alpha\": {\n        value: 1.0\n      },\n      \"time\": {\n        value: 0.0\n      },\n      \"size\": {\n        value: 1.0\n      },\n      \"distortionScale\": {\n        value: 20.0\n      },\n      \"textureMatrix\": {\n        value: new THREE.Matrix4()\n      },\n      \"sunColor\": {\n        value: new THREE.Color(0x7F7F7F)\n      },\n      \"sunDirection\": {\n        value: new THREE.Vector3(0.70707, 0.70707, 0)\n      },\n      \"eye\": {\n        value: new THREE.Vector3()\n      },\n      \"waterColor\": {\n        value: new THREE.Color(0x555555)\n      }\n    }]),\n    vertexShader: ['uniform mat4 textureMatrix;', 'uniform float time;', 'varying vec4 mirrorCoord;', 'varying vec4 worldPosition;', THREE.ShaderChunk['fog_pars_vertex'], THREE.ShaderChunk['shadowmap_pars_vertex'], 'void main() {', '\tmirrorCoord = modelMatrix * vec4( position, 1.0 );', '\tworldPosition = mirrorCoord.xyzw;', '\tmirrorCoord = textureMatrix * mirrorCoord;', '\tvec4 mvPosition =  modelViewMatrix * vec4( position, 1.0 );', '\tgl_Position = projectionMatrix * mvPosition;', THREE.ShaderChunk['fog_vertex'], THREE.ShaderChunk['shadowmap_vertex'], '}'].join('\\n'),\n    fragmentShader: ['uniform sampler2D mirrorSampler;', 'uniform float alpha;', 'uniform float time;', 'uniform float size;', 'uniform float distortionScale;', 'uniform sampler2D normalSampler;', 'uniform vec3 sunColor;', 'uniform vec3 sunDirection;', 'uniform vec3 eye;', 'uniform vec3 waterColor;', 'varying vec4 mirrorCoord;', 'varying vec4 worldPosition;', 'vec4 getNoise( vec2 uv ) {', '\tvec2 uv0 = ( uv / 103.0 ) + vec2(time / 17.0, time / 29.0);', '\tvec2 uv1 = uv / 107.0-vec2( time / -19.0, time / 31.0 );', '\tvec2 uv2 = uv / vec2( 8907.0, 9803.0 ) + vec2( time / 101.0, time / 97.0 );', '\tvec2 uv3 = uv / vec2( 1091.0, 1027.0 ) - vec2( time / 109.0, time / -113.0 );', '\tvec4 noise = texture2D( normalSampler, uv0 ) +', '\t\ttexture2D( normalSampler, uv1 ) +', '\t\ttexture2D( normalSampler, uv2 ) +', '\t\ttexture2D( normalSampler, uv3 );', '\treturn noise * 0.5 - 1.0;', '}', 'void sunLight( const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor ) {', '\tvec3 reflection = normalize( reflect( -sunDirection, surfaceNormal ) );', '\tfloat direction = max( 0.0, dot( eyeDirection, reflection ) );', '\tspecularColor += pow( direction, shiny ) * sunColor * spec;', '\tdiffuseColor += max( dot( sunDirection, surfaceNormal ), 0.0 ) * sunColor * diffuse;', '}', THREE.ShaderChunk['common'], THREE.ShaderChunk['packing'], THREE.ShaderChunk['bsdfs'], THREE.ShaderChunk['fog_pars_fragment'], THREE.ShaderChunk['lights_pars_begin'], THREE.ShaderChunk['shadowmap_pars_fragment'], THREE.ShaderChunk['shadowmask_pars_fragment'], 'void main() {', '\tvec4 noise = getNoise( worldPosition.xz * size );', '\tvec3 surfaceNormal = normalize( noise.xzy * vec3( 1.5, 1.0, 1.5 ) );', '\tvec3 diffuseLight = vec3(0.0);', '\tvec3 specularLight = vec3(0.0);', '\tvec3 worldToEye = eye-worldPosition.xyz;', '\tvec3 eyeDirection = normalize( worldToEye );', '\tsunLight( surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );', '\tfloat distance = length(worldToEye);', '\tvec2 distortion = surfaceNormal.xz * ( 0.001 + 1.0 / distance ) * distortionScale;', '\tvec3 reflectionSample = vec3( texture2D( mirrorSampler, mirrorCoord.xy / mirrorCoord.w + distortion ) );', '\tfloat theta = max( dot( eyeDirection, surfaceNormal ), 0.0 );', '\tfloat rf0 = 0.3;', '\tfloat reflectance = rf0 + ( 1.0 - rf0 ) * pow( ( 1.0 - theta ), 5.0 );', '\tvec3 scatter = max( 0.0, dot( surfaceNormal, eyeDirection ) ) * waterColor;', '\tvec3 albedo = mix( ( sunColor * diffuseLight * 0.3 + scatter ) * getShadowMask(), ( vec3( 0.1 ) + reflectionSample * 0.9 + reflectionSample * specularLight ), reflectance);', '\tvec3 outgoingLight = albedo;', '\tgl_FragColor = vec4( outgoingLight, alpha );', THREE.ShaderChunk['tonemapping_fragment'], THREE.ShaderChunk['fog_fragment'], '}'].join('\\n')\n  };\n  var material = new THREE.ShaderMaterial({\n    fragmentShader: mirrorShader.fragmentShader,\n    vertexShader: mirrorShader.vertexShader,\n    uniforms: THREE.UniformsUtils.clone(mirrorShader.uniforms),\n    transparent: true,\n    lights: true,\n    side: side,\n    fog: fog\n  });\n  material.uniforms[\"mirrorSampler\"].value = renderTarget.texture;\n  material.uniforms[\"textureMatrix\"].value = textureMatrix;\n  material.uniforms[\"alpha\"].value = alpha;\n  material.uniforms[\"time\"].value = time;\n  material.uniforms[\"normalSampler\"].value = normalSampler;\n  material.uniforms[\"sunColor\"].value = sunColor;\n  material.uniforms[\"waterColor\"].value = waterColor;\n  material.uniforms[\"sunDirection\"].value = sunDirection;\n  material.uniforms[\"distortionScale\"].value = distortionScale;\n  material.uniforms[\"eye\"].value = eye;\n  scope.material = material;\n\n  scope.onBeforeRender = function (renderer, scene, camera) {\n    mirrorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n    cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n    rotationMatrix.extractRotation(scope.matrixWorld);\n    normal.set(0, 0, 1);\n    normal.applyMatrix4(rotationMatrix);\n    view.subVectors(mirrorWorldPosition, cameraWorldPosition); // Avoid rendering when mirror is facing away\n\n    if (view.dot(normal) > 0) return;\n    view.reflect(normal).negate();\n    view.add(mirrorWorldPosition);\n    rotationMatrix.extractRotation(camera.matrixWorld);\n    lookAtPosition.set(0, 0, -1);\n    lookAtPosition.applyMatrix4(rotationMatrix);\n    lookAtPosition.add(cameraWorldPosition);\n    target.subVectors(mirrorWorldPosition, lookAtPosition);\n    target.reflect(normal).negate();\n    target.add(mirrorWorldPosition);\n    mirrorCamera.position.copy(view);\n    mirrorCamera.up.set(0, 1, 0);\n    mirrorCamera.up.applyMatrix4(rotationMatrix);\n    mirrorCamera.up.reflect(normal);\n    mirrorCamera.lookAt(target);\n    mirrorCamera.far = camera.far; // Used in WebGLBackground\n\n    mirrorCamera.updateMatrixWorld();\n    mirrorCamera.projectionMatrix.copy(camera.projectionMatrix); // Update the texture matrix\n\n    textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n    textureMatrix.multiply(mirrorCamera.projectionMatrix);\n    textureMatrix.multiply(mirrorCamera.matrixWorldInverse); // Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n    // Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n\n    mirrorPlane.setFromNormalAndCoplanarPoint(normal, mirrorWorldPosition);\n    mirrorPlane.applyMatrix4(mirrorCamera.matrixWorldInverse);\n    clipPlane.set(mirrorPlane.normal.x, mirrorPlane.normal.y, mirrorPlane.normal.z, mirrorPlane.constant);\n    var projectionMatrix = mirrorCamera.projectionMatrix;\n    q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n    q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n    q.z = -1.0;\n    q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14]; // Calculate the scaled plane vector\n\n    clipPlane.multiplyScalar(2.0 / clipPlane.dot(q)); // Replacing the third row of the projection matrix\n\n    projectionMatrix.elements[2] = clipPlane.x;\n    projectionMatrix.elements[6] = clipPlane.y;\n    projectionMatrix.elements[10] = clipPlane.z + 1.0 - clipBias;\n    projectionMatrix.elements[14] = clipPlane.w;\n    eye.setFromMatrixPosition(camera.matrixWorld); //\n\n    var currentRenderTarget = renderer.getRenderTarget();\n    var currentVrEnabled = renderer.vr.enabled;\n    var currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n    scope.visible = false;\n    renderer.vr.enabled = false; // Avoid camera modification and recursion\n\n    renderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\n    renderer.setRenderTarget(renderTarget);\n    renderer.clear();\n    renderer.render(scene, mirrorCamera);\n    scope.visible = true;\n    renderer.vr.enabled = currentVrEnabled;\n    renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n    renderer.setRenderTarget(currentRenderTarget);\n  };\n};\n\nTHREE.Water.prototype = Object.create(THREE.Mesh.prototype);\nTHREE.Water.prototype.constructor = THREE.Water;","map":{"version":3,"sources":["C:/Users/Em/Desktop/THe Frog v3/node_modules/three/examples/js/objects/Water.js"],"names":["THREE","Water","geometry","options","Mesh","call","scope","textureWidth","undefined","textureHeight","clipBias","alpha","time","normalSampler","waterNormals","sunDirection","Vector3","sunColor","Color","waterColor","eye","distortionScale","side","FrontSide","fog","mirrorPlane","Plane","normal","mirrorWorldPosition","cameraWorldPosition","rotationMatrix","Matrix4","lookAtPosition","clipPlane","Vector4","view","target","q","textureMatrix","mirrorCamera","PerspectiveCamera","parameters","minFilter","LinearFilter","magFilter","format","RGBFormat","stencilBuffer","renderTarget","WebGLRenderTarget","Math","isPowerOfTwo","texture","generateMipmaps","mirrorShader","uniforms","UniformsUtils","merge","UniformsLib","value","vertexShader","ShaderChunk","join","fragmentShader","material","ShaderMaterial","clone","transparent","lights","onBeforeRender","renderer","scene","camera","setFromMatrixPosition","matrixWorld","extractRotation","set","applyMatrix4","subVectors","dot","reflect","negate","add","position","copy","up","lookAt","far","updateMatrixWorld","projectionMatrix","multiply","matrixWorldInverse","setFromNormalAndCoplanarPoint","x","y","z","constant","sign","elements","w","multiplyScalar","currentRenderTarget","getRenderTarget","currentVrEnabled","vr","enabled","currentShadowAutoUpdate","shadowMap","autoUpdate","visible","setRenderTarget","clear","render","prototype","Object","create","constructor"],"mappings":"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","sourcesContent":["/**\n * @author jbouny / https://github.com/jbouny\n *\n * Work based on :\n * @author Slayvin / http://slayvin.net : Flat mirror for three.js\n * @author Stemkoski / http://www.adelphi.edu/~stemkoski : An implementation of water shader based on the flat mirror\n * @author Jonas Wagner / http://29a.ch/ && http://29a.ch/slides/2012/webglwater/ : Water shader explanations in WebGL\n */\n\nTHREE.Water = function ( geometry, options ) {\n\n\tTHREE.Mesh.call( this, geometry );\n\n\tvar scope = this;\n\n\toptions = options || {};\n\n\tvar textureWidth = options.textureWidth !== undefined ? options.textureWidth : 512;\n\tvar textureHeight = options.textureHeight !== undefined ? options.textureHeight : 512;\n\n\tvar clipBias = options.clipBias !== undefined ? options.clipBias : 0.0;\n\tvar alpha = options.alpha !== undefined ? options.alpha : 1.0;\n\tvar time = options.time !== undefined ? options.time : 0.0;\n\tvar normalSampler = options.waterNormals !== undefined ? options.waterNormals : null;\n\tvar sunDirection = options.sunDirection !== undefined ? options.sunDirection : new THREE.Vector3( 0.70707, 0.70707, 0.0 );\n\tvar sunColor = new THREE.Color( options.sunColor !== undefined ? options.sunColor : 0xffffff );\n\tvar waterColor = new THREE.Color( options.waterColor !== undefined ? options.waterColor : 0x7F7F7F );\n\tvar eye = options.eye !== undefined ? options.eye : new THREE.Vector3( 0, 0, 0 );\n\tvar distortionScale = options.distortionScale !== undefined ? options.distortionScale : 20.0;\n\tvar side = options.side !== undefined ? options.side : THREE.FrontSide;\n\tvar fog = options.fog !== undefined ? options.fog : false;\n\n\t//\n\n\tvar mirrorPlane = new THREE.Plane();\n\tvar normal = new THREE.Vector3();\n\tvar mirrorWorldPosition = new THREE.Vector3();\n\tvar cameraWorldPosition = new THREE.Vector3();\n\tvar rotationMatrix = new THREE.Matrix4();\n\tvar lookAtPosition = new THREE.Vector3( 0, 0, - 1 );\n\tvar clipPlane = new THREE.Vector4();\n\n\tvar view = new THREE.Vector3();\n\tvar target = new THREE.Vector3();\n\tvar q = new THREE.Vector4();\n\n\tvar textureMatrix = new THREE.Matrix4();\n\n\tvar mirrorCamera = new THREE.PerspectiveCamera();\n\n\tvar parameters = {\n\t\tminFilter: THREE.LinearFilter,\n\t\tmagFilter: THREE.LinearFilter,\n\t\tformat: THREE.RGBFormat,\n\t\tstencilBuffer: false\n\t};\n\n\tvar renderTarget = new THREE.WebGLRenderTarget( textureWidth, textureHeight, parameters );\n\n\tif ( ! THREE.Math.isPowerOfTwo( textureWidth ) || ! THREE.Math.isPowerOfTwo( textureHeight ) ) {\n\n\t\trenderTarget.texture.generateMipmaps = false;\n\n\t}\n\n\tvar mirrorShader = {\n\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\t\t\tTHREE.UniformsLib[ 'fog' ],\n\t\t\tTHREE.UniformsLib[ 'lights' ],\n\t\t\t{\n\t\t\t\t\"normalSampler\": { value: null },\n\t\t\t\t\"mirrorSampler\": { value: null },\n\t\t\t\t\"alpha\": { value: 1.0 },\n\t\t\t\t\"time\": { value: 0.0 },\n\t\t\t\t\"size\": { value: 1.0 },\n\t\t\t\t\"distortionScale\": { value: 20.0 },\n\t\t\t\t\"textureMatrix\": { value: new THREE.Matrix4() },\n\t\t\t\t\"sunColor\": { value: new THREE.Color( 0x7F7F7F ) },\n\t\t\t\t\"sunDirection\": { value: new THREE.Vector3( 0.70707, 0.70707, 0 ) },\n\t\t\t\t\"eye\": { value: new THREE.Vector3() },\n\t\t\t\t\"waterColor\": { value: new THREE.Color( 0x555555 ) }\n\t\t\t}\n\t\t] ),\n\n\t\tvertexShader: [\n\t\t\t'uniform mat4 textureMatrix;',\n\t\t\t'uniform float time;',\n\n\t\t\t'varying vec4 mirrorCoord;',\n\t\t\t'varying vec4 worldPosition;',\n\n\t\t\tTHREE.ShaderChunk[ 'fog_pars_vertex' ],\n\t\t\tTHREE.ShaderChunk[ 'shadowmap_pars_vertex' ],\n\n\t\t\t'void main() {',\n\t\t\t'\tmirrorCoord = modelMatrix * vec4( position, 1.0 );',\n\t\t\t'\tworldPosition = mirrorCoord.xyzw;',\n\t\t\t'\tmirrorCoord = textureMatrix * mirrorCoord;',\n\t\t\t'\tvec4 mvPosition =  modelViewMatrix * vec4( position, 1.0 );',\n\t\t\t'\tgl_Position = projectionMatrix * mvPosition;',\n\n\t\t\tTHREE.ShaderChunk[ 'fog_vertex' ],\n\t\t\tTHREE.ShaderChunk[ 'shadowmap_vertex' ],\n\n\t\t\t'}'\n\t\t].join( '\\n' ),\n\n\t\tfragmentShader: [\n\t\t\t'uniform sampler2D mirrorSampler;',\n\t\t\t'uniform float alpha;',\n\t\t\t'uniform float time;',\n\t\t\t'uniform float size;',\n\t\t\t'uniform float distortionScale;',\n\t\t\t'uniform sampler2D normalSampler;',\n\t\t\t'uniform vec3 sunColor;',\n\t\t\t'uniform vec3 sunDirection;',\n\t\t\t'uniform vec3 eye;',\n\t\t\t'uniform vec3 waterColor;',\n\n\t\t\t'varying vec4 mirrorCoord;',\n\t\t\t'varying vec4 worldPosition;',\n\n\t\t\t'vec4 getNoise( vec2 uv ) {',\n\t\t\t'\tvec2 uv0 = ( uv / 103.0 ) + vec2(time / 17.0, time / 29.0);',\n\t\t\t'\tvec2 uv1 = uv / 107.0-vec2( time / -19.0, time / 31.0 );',\n\t\t\t'\tvec2 uv2 = uv / vec2( 8907.0, 9803.0 ) + vec2( time / 101.0, time / 97.0 );',\n\t\t\t'\tvec2 uv3 = uv / vec2( 1091.0, 1027.0 ) - vec2( time / 109.0, time / -113.0 );',\n\t\t\t'\tvec4 noise = texture2D( normalSampler, uv0 ) +',\n\t\t\t'\t\ttexture2D( normalSampler, uv1 ) +',\n\t\t\t'\t\ttexture2D( normalSampler, uv2 ) +',\n\t\t\t'\t\ttexture2D( normalSampler, uv3 );',\n\t\t\t'\treturn noise * 0.5 - 1.0;',\n\t\t\t'}',\n\n\t\t\t'void sunLight( const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor ) {',\n\t\t\t'\tvec3 reflection = normalize( reflect( -sunDirection, surfaceNormal ) );',\n\t\t\t'\tfloat direction = max( 0.0, dot( eyeDirection, reflection ) );',\n\t\t\t'\tspecularColor += pow( direction, shiny ) * sunColor * spec;',\n\t\t\t'\tdiffuseColor += max( dot( sunDirection, surfaceNormal ), 0.0 ) * sunColor * diffuse;',\n\t\t\t'}',\n\n\t\t\tTHREE.ShaderChunk[ 'common' ],\n\t\t\tTHREE.ShaderChunk[ 'packing' ],\n\t\t\tTHREE.ShaderChunk[ 'bsdfs' ],\n\t\t\tTHREE.ShaderChunk[ 'fog_pars_fragment' ],\n\t\t\tTHREE.ShaderChunk[ 'lights_pars_begin' ],\n\t\t\tTHREE.ShaderChunk[ 'shadowmap_pars_fragment' ],\n\t\t\tTHREE.ShaderChunk[ 'shadowmask_pars_fragment' ],\n\n\t\t\t'void main() {',\n\t\t\t'\tvec4 noise = getNoise( worldPosition.xz * size );',\n\t\t\t'\tvec3 surfaceNormal = normalize( noise.xzy * vec3( 1.5, 1.0, 1.5 ) );',\n\n\t\t\t'\tvec3 diffuseLight = vec3(0.0);',\n\t\t\t'\tvec3 specularLight = vec3(0.0);',\n\n\t\t\t'\tvec3 worldToEye = eye-worldPosition.xyz;',\n\t\t\t'\tvec3 eyeDirection = normalize( worldToEye );',\n\t\t\t'\tsunLight( surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );',\n\n\t\t\t'\tfloat distance = length(worldToEye);',\n\n\t\t\t'\tvec2 distortion = surfaceNormal.xz * ( 0.001 + 1.0 / distance ) * distortionScale;',\n\t\t\t'\tvec3 reflectionSample = vec3( texture2D( mirrorSampler, mirrorCoord.xy / mirrorCoord.w + distortion ) );',\n\n\t\t\t'\tfloat theta = max( dot( eyeDirection, surfaceNormal ), 0.0 );',\n\t\t\t'\tfloat rf0 = 0.3;',\n\t\t\t'\tfloat reflectance = rf0 + ( 1.0 - rf0 ) * pow( ( 1.0 - theta ), 5.0 );',\n\t\t\t'\tvec3 scatter = max( 0.0, dot( surfaceNormal, eyeDirection ) ) * waterColor;',\n\t\t\t'\tvec3 albedo = mix( ( sunColor * diffuseLight * 0.3 + scatter ) * getShadowMask(), ( vec3( 0.1 ) + reflectionSample * 0.9 + reflectionSample * specularLight ), reflectance);',\n\t\t\t'\tvec3 outgoingLight = albedo;',\n\t\t\t'\tgl_FragColor = vec4( outgoingLight, alpha );',\n\n\t\t\tTHREE.ShaderChunk[ 'tonemapping_fragment' ],\n\t\t\tTHREE.ShaderChunk[ 'fog_fragment' ],\n\n\t\t\t'}'\n\t\t].join( '\\n' )\n\n\t};\n\n\tvar material = new THREE.ShaderMaterial( {\n\t\tfragmentShader: mirrorShader.fragmentShader,\n\t\tvertexShader: mirrorShader.vertexShader,\n\t\tuniforms: THREE.UniformsUtils.clone( mirrorShader.uniforms ),\n\t\ttransparent: true,\n\t\tlights: true,\n\t\tside: side,\n\t\tfog: fog\n\t} );\n\n\tmaterial.uniforms[ \"mirrorSampler\" ].value = renderTarget.texture;\n\tmaterial.uniforms[ \"textureMatrix\" ].value = textureMatrix;\n\tmaterial.uniforms[ \"alpha\" ].value = alpha;\n\tmaterial.uniforms[ \"time\" ].value = time;\n\tmaterial.uniforms[ \"normalSampler\" ].value = normalSampler;\n\tmaterial.uniforms[ \"sunColor\" ].value = sunColor;\n\tmaterial.uniforms[ \"waterColor\" ].value = waterColor;\n\tmaterial.uniforms[ \"sunDirection\" ].value = sunDirection;\n\tmaterial.uniforms[ \"distortionScale\" ].value = distortionScale;\n\n\tmaterial.uniforms[ \"eye\" ].value = eye;\n\n\tscope.material = material;\n\n\tscope.onBeforeRender = function ( renderer, scene, camera ) {\n\n\t\tmirrorWorldPosition.setFromMatrixPosition( scope.matrixWorld );\n\t\tcameraWorldPosition.setFromMatrixPosition( camera.matrixWorld );\n\n\t\trotationMatrix.extractRotation( scope.matrixWorld );\n\n\t\tnormal.set( 0, 0, 1 );\n\t\tnormal.applyMatrix4( rotationMatrix );\n\n\t\tview.subVectors( mirrorWorldPosition, cameraWorldPosition );\n\n\t\t// Avoid rendering when mirror is facing away\n\n\t\tif ( view.dot( normal ) > 0 ) return;\n\n\t\tview.reflect( normal ).negate();\n\t\tview.add( mirrorWorldPosition );\n\n\t\trotationMatrix.extractRotation( camera.matrixWorld );\n\n\t\tlookAtPosition.set( 0, 0, - 1 );\n\t\tlookAtPosition.applyMatrix4( rotationMatrix );\n\t\tlookAtPosition.add( cameraWorldPosition );\n\n\t\ttarget.subVectors( mirrorWorldPosition, lookAtPosition );\n\t\ttarget.reflect( normal ).negate();\n\t\ttarget.add( mirrorWorldPosition );\n\n\t\tmirrorCamera.position.copy( view );\n\t\tmirrorCamera.up.set( 0, 1, 0 );\n\t\tmirrorCamera.up.applyMatrix4( rotationMatrix );\n\t\tmirrorCamera.up.reflect( normal );\n\t\tmirrorCamera.lookAt( target );\n\n\t\tmirrorCamera.far = camera.far; // Used in WebGLBackground\n\n\t\tmirrorCamera.updateMatrixWorld();\n\t\tmirrorCamera.projectionMatrix.copy( camera.projectionMatrix );\n\n\t\t// Update the texture matrix\n\t\ttextureMatrix.set(\n\t\t\t0.5, 0.0, 0.0, 0.5,\n\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t);\n\t\ttextureMatrix.multiply( mirrorCamera.projectionMatrix );\n\t\ttextureMatrix.multiply( mirrorCamera.matrixWorldInverse );\n\n\t\t// Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n\t\t// Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n\t\tmirrorPlane.setFromNormalAndCoplanarPoint( normal, mirrorWorldPosition );\n\t\tmirrorPlane.applyMatrix4( mirrorCamera.matrixWorldInverse );\n\n\t\tclipPlane.set( mirrorPlane.normal.x, mirrorPlane.normal.y, mirrorPlane.normal.z, mirrorPlane.constant );\n\n\t\tvar projectionMatrix = mirrorCamera.projectionMatrix;\n\n\t\tq.x = ( Math.sign( clipPlane.x ) + projectionMatrix.elements[ 8 ] ) / projectionMatrix.elements[ 0 ];\n\t\tq.y = ( Math.sign( clipPlane.y ) + projectionMatrix.elements[ 9 ] ) / projectionMatrix.elements[ 5 ];\n\t\tq.z = - 1.0;\n\t\tq.w = ( 1.0 + projectionMatrix.elements[ 10 ] ) / projectionMatrix.elements[ 14 ];\n\n\t\t// Calculate the scaled plane vector\n\t\tclipPlane.multiplyScalar( 2.0 / clipPlane.dot( q ) );\n\n\t\t// Replacing the third row of the projection matrix\n\t\tprojectionMatrix.elements[ 2 ] = clipPlane.x;\n\t\tprojectionMatrix.elements[ 6 ] = clipPlane.y;\n\t\tprojectionMatrix.elements[ 10 ] = clipPlane.z + 1.0 - clipBias;\n\t\tprojectionMatrix.elements[ 14 ] = clipPlane.w;\n\n\t\teye.setFromMatrixPosition( camera.matrixWorld );\n\n\t\t//\n\n\t\tvar currentRenderTarget = renderer.getRenderTarget();\n\n\t\tvar currentVrEnabled = renderer.vr.enabled;\n\t\tvar currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n\n\t\tscope.visible = false;\n\n\t\trenderer.vr.enabled = false; // Avoid camera modification and recursion\n\t\trenderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\n\t\trenderer.setRenderTarget( renderTarget );\n\t\trenderer.clear();\n\t\trenderer.render( scene, mirrorCamera );\n\n\t\tscope.visible = true;\n\n\t\trenderer.vr.enabled = currentVrEnabled;\n\t\trenderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n\n\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t};\n\n};\n\nTHREE.Water.prototype = Object.create( THREE.Mesh.prototype );\nTHREE.Water.prototype.constructor = THREE.Water;\n"]},"metadata":{},"sourceType":"script"}